<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Google Snake — Minimal Clone</title>
<style>
  :root{
    --bg:#0b1220;
    --panel:#0f1724;
    --muted:#9aa6b2;
    --accent:#4ade80;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#071322,#071a2a);font-family:Inter,system-ui,Segoe UI,Roboto,Arial;color:#e6eef6;display:flex;align-items:center;justify-content:center}
  .wrap{width:760px;max-width:95%;display:grid;grid-template-columns:1fr 260px;gap:12px}
  .panel{background:rgba(255,255,255,0.03);padding:12px;border-radius:10px;box-shadow:0 6px 20px rgba(0,0,0,0.5)}
  canvas{display:block;width:100%;height:auto;background:#071322;border-radius:8px}
  .controls{display:flex;flex-direction:column;gap:8px}
  .row{display:flex;gap:8px;align-items:center;justify-content:space-between}
  button{padding:8px 10px;border-radius:8px;border:none;background:var(--accent);color:#042;font-weight:700;cursor:pointer}
  .ghost{background:#1b2532;color:var(--muted)}
  label{font-size:13px;color:var(--muted);display:flex;flex-direction:column;gap:6px}
  input[type="range"]{width:100%}
  small{color:var(--muted)}
  @media (max-width:820px){.wrap{grid-template-columns:1fr}}
</style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <h2 style="margin:0 0 6px 0">Google Snake — Minimal</h2>
      <small>Arrows / WASD to move · Space = pause · R = restart</small>
      <div style="margin:10px 0" class="panel">
        <canvas id="c" width="600" height="600"></canvas>
      </div>

      <div class="row">
        <div>Score: <strong id="score">0</strong></div>
        <div>Best: <strong id="best">0</strong></div>
      </div>

      <div style="display:flex;gap:8px;margin-top:10px">
        <button id="start">Start</button>
        <button id="pause" class="ghost">Pause</button>
        <button id="reset" class="ghost">Reset</button>
      </div>
    </div>

    <aside class="panel controls">
      <label>
        Grid (cells per side)
        <input id="grid" type="number" min="10" max="60" value="20"/>
      </label>

      <label>
        Speed (moves/sec)
        <input id="speed" type="range" min="3" max="20" value="8"/>
        <div><small id="spdLabel">8</small></div>
      </label>

      <label>
        Snake color
        <input id="snakeColor" type="color" value="#4ade80"/>
      </label>

      <label>
        Apple color
        <input id="appleColor" type="color" value="#ff4d4d"/>
      </label>

      <div style="font-size:13px;color:var(--muted);margin-top:6px">
        Classic mechanics: wrap-around, one apple at a time, grows by 1 per apple.
      </div>
    </aside>
  </div>

<script>
(() => {
  // DOM
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', {alpha:false});
  const startBtn = document.getElementById('start');
  const pauseBtn = document.getElementById('pause');
  const resetBtn = document.getElementById('reset');
  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('best');
  const gridInput = document.getElementById('grid');
  const speedInput = document.getElementById('speed');
  const spdLabel = document.getElementById('spdLabel');
  const snakeColorInput = document.getElementById('snakeColor');
  const appleColorInput = document.getElementById('appleColor');

  // State
  let grid = clamp(parseInt(gridInput.value,10) || 20, 10, 60);
  let cell = Math.floor(canvas.width / grid);
  let speed = Number(speedInput.value) || 8; // moves per second
  let tickMs = 1000 / speed;
  let snakeColor = snakeColorInput.value;
  let appleColor = appleColorInput.value;

  let running = false;
  let paused = false;
  let last = 0;

  let dir = {x:1,y:0};
  let nextDir = {x:1,y:0};
  let snake = [];
  let apple = null;
  let score = 0;
  let best = Number(localStorage.getItem('gs_best') || 0);
  bestEl.textContent = best;

  // Helpers
  function clamp(n,a,b){return Math.max(a,Math.min(b,n));}
  function rnd(n){return Math.floor(Math.random()*n);}
  function key(p){return p.x+','+p.y;}
  function inSnake(x,y){ return snake.some(s=>s.x===x && s.y===y); }

  function resizeForGrid(){
    // keep canvas square and scale for clarity
    const size = Math.min(800, Math.max(300, grid * 24));
    canvas.width = size;
    canvas.height = size;
    cell = Math.floor(canvas.width / grid);
  }

  // Init
  function reset(full=true){
    grid = clamp(parseInt(gridInput.value,10)||20,10,60);
    speed = Number(speedInput.value)||8;
    tickMs = 1000 / speed;
    snakeColor = snakeColorInput.value;
    appleColor = appleColorInput.value;
    spdLabel.textContent = speed;

    resizeForGrid();

    // start snake centered length 3
    const mid = Math.floor(grid/2);
    snake = [{x:mid-1,y:mid},{x:mid,y:mid},{x:mid+1,y:mid}];
    dir = {x:1,y:0};
    nextDir = {x:1,y:0};
    score = 0;
    apple = null;
    running = false;
    paused = false;
    last = performance.now();
    scoreEl.textContent = score;
    bestEl.textContent = best;
    spawnApple();
    draw();
  }

  function spawnApple(){
    // pick a free cell
    const free = [];
    for(let x=0;x<grid;x++){
      for(let y=0;y<grid;y++){
        if(!inSnake(x,y)) free.push({x,y});
      }
    }
    if(free.length === 0) { apple = null; return; }
    apple = free[rnd(free.length)];
  }

  function step(){
    dir = nextDir;
    const head = {...snake[snake.length-1]};
    head.x += dir.x;
    head.y += dir.y;

    // wrap-around
    if(head.x < 0) head.x = grid-1;
    if(head.x >= grid) head.x = 0;
    if(head.y < 0) head.y = grid-1;
    if(head.y >= grid) head.y = 0;

    // self-collision?
    if(inSnake(head.x, head.y)){
      // game over
      running = false;
      paused = false;
      flashDeath();
      return;
    }

    snake.push(head);

    // apple?
    if(apple && head.x === apple.x && head.y === apple.y){
      score += 10;
      scoreEl.textContent = score;
      if(score > best){ best = score; localStorage.setItem('gs_best', best); bestEl.textContent = best; }
      spawnApple();
    } else {
      snake.shift();
    }
  }

  function flashDeath(){
    // simple red flash then draw final frame
    draw(true);
    setTimeout(draw, 150);
  }

  // Rendering
  function draw(death=false){
    // background
    ctx.fillStyle = '#071322';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // subtle grid
    ctx.strokeStyle = 'rgba(255,255,255,0.02)';
    ctx.lineWidth = 1;
    for(let i=0;i<=grid;i++){
      const p = i*cell + 0.5;
      ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,canvas.height); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(canvas.width,p); ctx.stroke();
    }

    // apple
    if(apple){
      drawCell(apple.x, apple.y, appleColor, true);
    }

    // snake
    for(let i=0;i<snake.length;i++){
      const part = snake[i];
      const isHead = i === snake.length - 1;
      const col = isHead ? shade(snakeColor, -12) : snakeColor;
      drawCell(part.x, part.y, col, true);
    }

    if(death){
      ctx.fillStyle = 'rgba(255,40,40,0.12)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
    }
  }

  function drawCell(gx, gy, color, rounded){
    const px = gx*cell;
    const py = gy*cell;
    const pad = Math.max(1, Math.floor(cell*0.08));
    const w = cell - pad*2;
    const r = Math.max(2, Math.floor(cell*0.18));
    // rounded rect
    ctx.beginPath();
    ctx.moveTo(px+pad+r, py+pad);
    ctx.arcTo(px+pad+w, py+pad, px+pad+w, py+pad+h??0, r); // fallback-safe (will not error)
    // simpler rounded rect fallback to avoid arcTo quirks:
    roundRect(ctx, px+pad, py+pad, w, w, r);
    ctx.fillStyle = color;
    ctx.fill();
  }

  // simple round rect util
  function roundRect(ctx,x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  function shade(hex, pct){
    // small integer shift
    const n = parseInt(hex.replace('#',''),16);
    let r = (n>>16) + pct;
    let g = ((n>>8)&0xff) + pct;
    let b = (n & 0xff) + pct;
    r = clamp(r,0,255); g = clamp(g,0,255); b = clamp(b,0,255);
    return '#' + ((1<<24) + (r<<16) + (g<<8) + b).toString(16).slice(1);
  }

  // Input
  window.addEventListener('keydown', (e) => {
    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d','W','A','S','D',' ','r','R'].includes(e.key)) e.preventDefault();
    if(e.key === ' '){ togglePause(); return; }
    if(e.key === 'r' || e.key === 'R'){ reset(); start(); return; }

    let nd = null;
    switch(e.key){
      case 'ArrowUp': case 'w': case 'W': nd = {x:0,y:-1}; break;
      case 'ArrowDown': case 's': case 'S': nd = {x:0,y:1}; break;
      case 'ArrowLeft': case 'a': case 'A': nd = {x:-1,y:0}; break;
      case 'ArrowRight': case 'd': case 'D': nd = {x:1,y:0}; break;
    }
    if(nd){
      // prevent immediate reverse
      if(nd.x === -dir.x && nd.y === -dir.y) return;
      nextDir = nd;
      if(!running) start();
    }
  });

  // UI hooks
  startBtn.addEventListener('click', start);
  pauseBtn.addEventListener('click', togglePause);
  resetBtn.addEventListener('click', ()=>{ reset(); });

  speedInput.addEventListener('input', ()=>{
    speed = Number(speedInput.value);
    tickMs = 1000 / speed;
    spdLabel.textContent = speed;
  });

  gridInput.addEventListener('change', ()=> {
    // apply on reset
    grid = clamp(parseInt(gridInput.value,10)||20,10,60);
  });

  snakeColorInput.addEventListener('input', ()=> snakeColor = snakeColorInput.value);
  appleColorInput.addEventListener('input', ()=> appleColor = appleColorInput.value);

  // Loop
  function start(){
    if(!running){
      running = true;
      paused = false;
      last = performance.now();
      requestAnimationFrame(loop);
    }
  }

  function togglePause(){
    if(!running) return;
    paused = !paused;
    pauseBtn.textContent = paused ? 'Resume' : 'Pause';
    if(!paused) last = performance.now();
  }

  function loop(now){
    if(!running) return;
    if(!paused){
      if(now - last >= tickMs){
        // catch up if delayed (run multiple steps if necessary)
        const steps = Math.max(1, Math.floor((now - last) / tickMs));
        for(let i=0;i<steps;i++){
          step();
        }
        last = now;
        draw();
      }
    }
    requestAnimationFrame(loop);
  }

  // Start initial state
  reset();

})();
</script>
</body>
</html>
